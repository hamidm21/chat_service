<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: room_controller.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: room_controller.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const kafka_log = require('debug')('goftare:kafka');
const winston = require('../utils/logger');
const validator = require('../utils/validator');
const { producer, km } = require('../utils/kafka');
const mongoose = require('mongoose');
const moment = require('moment-jalaali');
const room_dao = require('../dao/room_dao');
const user_dao = require('../dao/user_dao');
const config = require('../config/config');

/**
 * joinRoom is the corresponding function for join_room socket
 * @param {Object} io - socket io object   
 * @param {Object} socket - user socket object 
 * @param {Object} data - data object provided by the client side
 * @arg {ID} room_id - room id provided by data object
 * @arg {ID} joined_id - id of the joined member provided by data object
 * @returns {callback} successful if user successfully join the room
 * @emits object - containes the joined user id and members inside the room
 * @throws {emit} to emit errors in the future
 * @description
 * takes a user's id and socket_id then joines it into the redis room and socket io room also saves the user socket in redis 
 * @async
 */

exports.joinRoom = async (io, socket, data, callback) => {
	const {
		room_id,
		joined_id
	} = data;
	try {
		const valid = validator.joi.validate(data, validator.joinRoom);
		if (valid.error) {
			callback(Object.assign({}, config.RESPONSE, {
				result: false,
				message: 'input is not valid',
				data: valid.error
			}));
		} else {
			const members = await room_dao.joinSocketToRoom(room_id, socket.id, joined_id);
			if (members) {
				socket.join(room_id);
				/**
				 * @memberof socket_handler - this is a backend event
				 * @event joined_room
				 * @emits joined_id - the joined user id
				 * @emits members - the array of members objects
				 * @description the answer of the join room is an event named joined_room
				 *  which gives back the joined id and the "online" members 
				 */
				io.to(room_id).emit('joined_room', Object.assign({}, config.RESPONSE, {
					message: 'successful',
					data: {
						joined_id,
						members
					}
				}));
				callback(Object.assign({}, config.RESPONSE, {
					message: 'joined_room'
				}));
			} else
				callback(Object.assign({}, config.RESPONSE, {
					result: false,
					message: 'failed'
				}));
		}
	} catch (e) {
		callback(Object.assign({}, config.RESPONSE, {
			result: false,
			message: e.message,
			data: {
				e
			}
		}));
		winston.error(`error in joinRoom function - ${e.status || 500} - ${e.message} - ${e.stack} - ${new Date()}`);
		throw e;
	}
};

exports.createRoom = async (io, socket, data, callback) => {

	const {
		_id,
		members,
		creator_id
	} = data;
	try {
		const valid = validator.joi.validate(data, validator.createRoom);
		if (valid.error) {
			callback(Object.assign(config.RESPONSE, {
				result: false,
				message: 'input is not valid',
				data: valid.error
			}));
		} else {
			const sockets = [];

			const saved = await room_dao.joinSocketToRoom(_id, socket.id, creator_id);
			if (saved) {
				for (const member of members) {
					const memberSockets = await user_dao.getUserSocketById(member.user_id);
					kafka_log(memberSockets);
					for (const memberSocket of memberSockets) {
						sockets.push(memberSocket);
					}
				}
			}

			// const created = await room_dao.saveRoom(room_id, sockets);
			kafka_log('........................\n' + sockets + '\n.............................');
			const keyedMessage = new km('readMessage', JSON.stringify({
				text: 'room_created',
				room_id: _id,
				timestamp: new Date().getTime(),
				moment: moment().format('jYYYY/jMM/jDD HH:mm:ss'),
				sender_id: creator_id,
				message_id: mongoose.Types.ObjectId() 
			}));
			producer.send([Object.assign(config.PAYLOAD, {
				messages: [keyedMessage]
			})], function (e, result) {
				if(e){
					callback(Object.assign({}, config.RESPONSE, {
						result: false,
						message: 'kafka error',
						data: e
					}));
				}else {
					if (sockets.length !== 0) {
						for (const socket of sockets) {
							/**
							 * @memberof socket_handler - this is a backend event
							 * @event new_room
							 * @emits _id - the room id
							 * @emits members - new room members
							 * @description - this event indicates that a new room is
							 *  created and is supposed to emit a "join_room" after reciving 
							 */
							io.to(socket).emit('new_room', Object.assign({}, config.RESPONSE, {
								_id,
								members
							}));
						}
						callback(Object.assign({}, config.RESPONSE, {
							message: 'room_created',
							data: result
						}));
		
					} else
						callback(Object.assign({}, config.RESPONSE, {
							result: false,
							message: 'failed to create the room by socket'
						}));
				}
			});
		}
	} catch (e) {
		callback(Object.assign({}, config.RESPONSE, {
			result: false,
			message: e.message,
			data: e
		}));
		winston.error(`error in joinRoom function - ${e.status || 500} - ${e.message} - ${e.stack} - ${new Date()}`);
	}
};

/**
 * disconnecting is the corresponding function for disconneting socket 
 * @param {Object} io - socket io object   
 * @param {Object} socket - user socket object
 * @arg {ID[]} rooms - takes the joined rooms for the disconnecting user from socket object
 * @emits sender_id - id of the disconnecting user
 * @throws {emit} to emit errors in the future
 * @async
 */

exports.disconnecting = async (io, socket) => {
	const rooms = Object.keys(socket.rooms).filter(room => typeof room === 'string' &amp;&amp; !!room &amp;&amp; room.length != 20);
	try {
		const removedSocket = await room_dao.removeSocketFromRoom(rooms, socket.id);
		for (const room of removedSocket.rooms) {
			/**
			 * @memberof socket_handler
			 * @event disconnected - this event happens when a user is disconnected from socket_io
			 * @emits sender_id - id of the user who is disconnected
			 * @description - user is disconnecting  socket_io
			 */
			io.to(room).emit('disconnected', Object.assign({}, config.RESPONSE, {
				message: 'user disconnected',
				data: {
					sender_id: removedSocket.sender_id
				}
			}));
		}
	} catch (e) {
		winston.error(`error in disconnect - ${e.status || 500} - ${e.message} - ${e.stack} - ${new Date()}`);
		throw e;
	}
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Events</h3><ul><li><a href="socket_handler.html#.event:disconnected-thiseventhappenswhenauserisdisconnectedfromsocket_io">disconnected - this event happens when a user is disconnected from socket_io</a></li><li><a href="socket_handler%2520-%2520this%2520is%2520a%2520backend%2520event.html#.event:joined_room">joined_room</a></li><li><a href="socket_handler%2520-%2520this%2520is%2520a%2520backend%2520event.html#.event:new_room">new_room</a></li><li><a href="socket_handler%2520-%2520this%2520is%2520a%2520backend%2520event.html#.event:read_message">read_message</a></li><li><a href="socket_handler%2520-%2520this%2520is%2520a%2520backend%2520event.html#.event:send_message">send_message</a></li><li><a href="socket_handler%2520-%2520this%2520is%2520a%2520backend%2520event.html#.event:start_typing">start_typing</a></li><li><a href="socket_handler%2520-%2520this%2520is%2520a%2520backend%2520event.html#.event:stop_typing">stop_typing</a></li></ul><h3>Global</h3><ul><li><a href="global.html#disconnecting">disconnecting</a></li><li><a href="global.html#isTyping">isTyping</a></li><li><a href="global.html#joinRoom">joinRoom</a></li><li><a href="global.html#newMessage">newMessage</a></li><li><a href="global.html#readMessage">readMessage</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Feb 27 2019 22:24:19 GMT+0330 (Iran Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
